# WucDesignPatterns

## 设计模式

能够综合考虑设计模式的选型使用**`*（目的是能够基于业务与当前代码结构考虑设计模式的适用性）`**

### 资料

[走向软件灵活设计之路-架构职责与设计原则与UML](https://www.processon.com/view/link/62fcf9fd7d9c0808a2d81a79)
[使用最多的设计模式~单例与工厂](https://www.processon.com/view/link/62ff30081e08530609509afe)

### 代码优化第一步~面向对象六大原则

- 代码优化第一步~单一职责
- 稳定性与灵活性的基础~开闭原则
- 扩展性的延伸~里氏替换原则
- 让项目拥有多变的可能~依赖倒置原则
- 灵活性的延伸~接口隔离原则
- 扩展的更多可能性~迪米特原则

#### 代码优化第一步~单一职责

##### 定义

一个类当中，应该仅有一个引起它变化的原因。简单来说，一个类中应该是一组相关性很高的函数封装。

##### 案例

以图片加载类com.wuc.designpattern.imageloader.question.ImageLoader为例；

**问题**

- ImageLoader 的这个类本身主体目的是做 Image 加载，它的缓存业务应该是一个独立的封装；
- 如果是写在一起，那么我的缓存业务的变更会导致图片加载业务跟着变更；

**变更思路**

- 将图片加载行为与缓存行为独立

#### 稳定性与灵活性的基础~开闭原则

##### 定义

软件中的对象（类、模块、函数等）应该对于修改是封闭的。

##### 案例

以图片加载类com.wuc.designpattern.imageloader.question.ImageLoader为例；

**问题**

- 使用内存缓存时用户不能够兼顾使用sd卡，如果要使用需要补充大量的判断；
- 对于用户提供的功能从需求上来说，不能够达到让用户自由选择，单个或者是全部一起使用；
- 如果要完成第一次从网络中取，其它时候从本地取这种业务思路，那么需要补充的判断太多；

**变更思路**

- 抽离出独立业务，将不同方案做成一个独立的类，内部使用依赖注入完成变化；

依赖注入具体代码如下：

```
/*依赖注入*/
public void setImageCache(ImageCache cache) {
    mImageCache = cache;
}
```

#### 扩展性的延伸~里氏替换原则

##### 定义

- 任何使用基类的地方，都可以透明（安全，不会出现行为不一致）的使用其子类；
- 继承：子类拥有父类的一切属性和行为，任何父类出现的地方，都可以用子类来代替；
- 父类有的，子类必须有，如果父类中出现类子类不应该有的东西，那么就应该断掉继承，再来一个父类，包含了都有的东西；
- 子类可以有自己的属性和行为，子类出现的地方，父类不一定能代替（白马飞马）；
- 父类实现的东西，子类就不要再写了（就是不要new隐藏），有时候会出现意想不到的地方，行为不一致，如果想修改父类的行为，通过abstract或者virtual声明属性、字段、变量，尽量声明为父类。

##### 案例

代码案例在com.wuc.designpattern.imageloader.lishitihaun报名下：

里氏替换原则的最主体目的是推荐使用继承，由一个对象A负责去组织使用，然后用继承结构去进行多态化调用；
充分利用继承的优点（代码重用、提高扩展性）

#### 让项目拥有多变的可能~依赖倒置原则

##### 定义

高层模块不应该依赖于低层模块，二者应该是通过抽象依赖，依赖抽象，而不是依赖细节，尽量使用抽象，80%的设计模式都是跟抽象有关（接口也可以）。
属性、字段、方法参数、返回值。。。。尽量都是抽象。

抽象：接口/抽象类---可以包含没有实现的元素

细节：普通类（子类）---一切都是确定的

这个原则的主要目的是为了让接口的使用最大化，我们内部使用具体功能的使用，不要直接new Impl()实现类而是选择用接口承接

##### 案例

**错误代码：**

```
public class ImageLoader {
    /**
     * 图片缓存
     */
    MemoryCache mImageCache = new MemoryCache();
    /**
     * 线程池,线程数量为CPU的数量
     */
    ExecutorService mExecutorService = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());
    private Handler mUiHandler = new Handler();

    /**
     * 依赖注入
     * @param cache 图片缓存
     */
    public void setImageCache(MemoryCache cache) {
        mImageCache = cache;
    }
}    
```

**问题**

- 上面代码中，ImageLoader 直接依赖于 MemoryCache 类，这个类是一个实现类，有具体功能，相当于当前直接依赖于细节；
- 那么当内部类要替换方案的时候就必须要修改 ImageLoader 类的代码

**变更思路**

- 正确代码：

```
public interface ImageCache {

    Bitmap get(String url);

    void put(String url, Bitmap bitmap);
}
```

- 依赖抽象，而不是依赖具体；

#### 灵活性的延伸~接口隔离原则

##### 定义

客户端不应该依赖它不需要的接口，一个类对另外一个类的依赖应该建立在最小的接口上，在工作中，80%都是用接口。

##### 案例

**错误代码：**

```
 public void put(String url, Bitmap bmp) {
        // 将Bitmap写入文件中
        FileOutputStream fos = null;
        try {
            // 构建图片的存储路径 ( 省略了对url取md5)
            fos = new FileOutputStream("sdcard/cache/" + imageUrl2MD5(url));
            bmp.compress(Bitmap.CompressFormat.JPEG, 100, fos);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } finally {
            if (fos != null) {
                try {
                    fos.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
 }
```

**问题**

- 上面代码的可读性非常差，在这里 FileOutputStream 实现了 Closeable 接口，这个接口有100+实现；
- 那么后面我们所有的代码，只要是碰到有这个实现 close 的地方都需要进行异常捕捉
- 代码冗余、可读性差

**变更思路**
com.wuc.designpattern.imageloader.utils.CloseUtils 工具类

- 写一个关闭工具类做一定的统一处理
- 如果出现问题，在 close 这一层并没有暴露出更多的代码信息，这里是隔离的意思。

#### 扩展的更多可能性~迪米特原则

##### 定义

- 一个对象应该对其他对象保持最少的了解，只与直接的朋友通信。
- 面向对象----万物皆对象----类与类交互才能产生功能，这不就是耦合了吗？要高内聚低耦合
- 类与类之间的关系：
    - 纵向：继承~实现（最密切）
    - 横向：聚合>组合>包含>依赖（出现在方法内部)
- 迪米特法则：降低类与类之间的耦合，只与直接的朋友通信，就是要尽量遊免依款更多类型
- 迪米特法则又叫最少知识原则.
- 只和你的直接朋友交谈，不跟“陌生人”说话(Taik only to your immodiate friends and not to strangers).
- 其含义是：如果两个软件安体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。
- 米特法则中的“朋友”是指：当前对象本身. 当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。

##### 案例

以com.wuc.designpattern.imageloader.dimierte包下代码为例；

- 迪米特原则更多的是在于设计层面对于业务的划分
- 他的宗旨是尽可能的将独立对象的业务最小化，像上面这种，租户与房间从业务角度看，中介出现的意义实际上就是类似于帮我
  们处理一次过滤

**问题**

- 但是在 .dimierte 包这个代码中，租户与房间产生了交集，同时弱化了中介的功能，导致三者之间的出现纠缠不清，职责划分不明确的
  情况

**变更思路**

- 这里迪米特强调的是在一个完整事件中对象之间的职能划分问题；
- 变更后的代码在com.wuc.designpattern.imageloader.dimierte.refactor包中

### 单例模式

#### 定义

指一个类只有一个实例，且该类能自行创建这个实例的一种模式。例如，Windows
中只能打开一个任务管理器，这样可以避免因打开多个任务管理器窗口而造成内存资源浪费，或出现各个窗口显示内容的不一致等错误。

#### 使用场景

确保某个类有且只有一个对象的场景，例如创建一个对象需要消耗的资源过多，如要访问 IO 和数据库等资源。

#### 优点与缺点

##### 优点

- 由于单例模式在内存中只有一个实例，减少了内存开支，特别是一个对象需要频繁地创建、销毀时，而且创建或销毁时性能又无
  法优化，单例模式的优势就非常明品。
- 由于单例模式只生成一个实例，所以减少了系統的性能开销，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依
  赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后用永久驻留内存的方式来解决；
- 单例模式可以迎免对资源的多重占用，例如一个写文件动作，由于只有一个实例存在内存中，迎免对同一个资源文件的同时写操
  作。

##### 缺点

单例模式一般没有接口，扩展很困难，若要扩展，除了修改代码基本没有第二种途径可以实现。
